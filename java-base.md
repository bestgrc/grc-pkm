# java基础

## 一 配置环境变量

1.  新建->变量名"JAVA_HOME"，

    变量值"C:\Java\jdk1.8.0_05"（即JDK的安装路径） 

2.  编辑->变量名"Path"，在原变量值的最后面加上“;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin” 

3.  新建->变量名“CLASSPATH”,变量值“.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”

### java配置环境变量以及原因

>   参考资料
>
>   -   [JAVA为什么要配置环境变量，怎样配置](https://www.cnblogs.com/zhangpengshou/p/4232204.html)
>   -   [Java环境变量中classpath是必须配置吗](https://zhidao.baidu.com/question/1605930365893725827.html)

| 环境变量  | 内容            | 原因                   |
| --------- | --------------- | ---------------------- |
| JAVA_HOME | JDK的安装目录   | 便于其他环境变量的引用 |
| CLASSPATH | %JAVA_HOME%\lib | 指定标准类库路径       |
| path      | %JAVA_HOME%\bin | 指定可执行文件的路径   |



### jre和jdk区别 

>   参考资料
>
>   -   [JDK and JRE File Structure](https://docs.oracle.com/javase/6/docs/technotes/tools/windows/jdkfiles.html)

-   jre：java运行时环境，包含java虚拟机和java核心类库。
-   jdk：java开发工具包，包含jre和一些java小工具。

![jdk](../picture/%E9%9D%A2%E8%AF%95%E9%A2%98/jdk.PNG)





## 二 编辑和运行java程序

### java程序的过程编译运行过程：

1. .java源文件 		 	使用javac.exe进行**编译**
2. .class字节码文件  		使用java虚拟机 java.exe进行**加载**
3. 实际程序

>    java虚拟机执行应用程序三大特点
>
>   1.  动态性
>   2.  异常处理
>   3.  多线程



## 三 java面向对象
> 面向对象与面向过程的区别：划分问题的方法是看“功能”还是看“步骤”

### 面向对象三大特征

#### 1 封装

#### 2 继承

#### 3 多态

##### 1. 形式

-   将接口从具体的实施细节中分离出来，即实现了"是什么"与"怎样做"两个模块的分离。

##### 2. 优点	

-   代码的组织以及可读性获得改善
-   易于扩展

### 面向对象设计七大原则
1. 单一职责原则（Single Responsibility Principle）：每一个类应该专注于做一件事情。
2. 里氏替换原则（Liskov Substitution Principle）：超类存在的地方，子类是可以替换的。
3. 依赖倒置原则（Dependence Inversion Principle）：实现尽量依赖抽象，不依赖具体实现。
4. 接口隔离原则（Interface Segregation Principle）：应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。
5. 迪米特法则（Law Of Demeter）：又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。
6. 开闭原则（Open Close Principle）：面向扩展开放，面向修改关闭。
7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）：尽量使用组合/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。



## 四 java数据类型

### 基本数据类型

### 引用数据类型

1.  一切类
2.  数组
3.  接口

## 五 this的三种用法

1.  调用本类中属性
2.  调用构造方法 （只能放在构造方法第一行）
3.  标识当前对象



## 六 static的作用

>   参考资料：
>
>   -   [java中static作用详解](https://zhidao.baidu.com/question/294516388.html)

static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。

被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。

只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。

用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。

static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用--废话），但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，private是访问权限限定，static表示不要实例化就可以使用，这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。



## 七 接口和抽象类的区别

#### 设计层面：抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。

>   参考资料
>
>   -   [Java抽象类与接口的区别](http://www.importnew.com/12399.html)

-   抽象类是对**类**的抽象，用来捕捉子类的通用特性；<br>接口是对**动作**的抽象，是抽象方法的集合。

| **参数**           | **抽象类**                                                   | **接口**                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 默认的方法实现     | 它可以有默认的方法实现                                       | 接口完全是抽象的。它根本不存在方法的实现                     |
| 实现               | 子类使用**extends**关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字**implements**来实现接口。它需要提供接口中所有声明的方法的实现 |
| 构造器             | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 与正常Java类的区别 | 除了你不能实例化抽象类之外，它和普通Java类没有任何区别       | 接口是完全不同的类型                                         |
| 访问修饰符         | 抽象方法可以有**public**、**protected**和**default**这些修饰符 | 接口方法默认修饰符是**public**。你不可以使用其它修饰符。     |
| main方法           | 抽象方法可以有main方法并且我们可以运行它                     | 接口没有main方法，因此我们不能运行它。                       |
| 多继承             | 抽象方法可以继承一个类和实现多个接口                         | 接口只可以继承一个或多个其它接口                             |
| 速度               | 它比接口速度要快                                             | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。   |
| 添加新方法         | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 | 如果你往接口中添加方法，那么你必须改变实现该接口的类。       |



## 八 String、StringBuffer、StringBuilder

|              | String         | StringBuffer | StringBuilder |
| ------------ | -------------- | ------------ | ------------- |
| 是否可变     | 不可变字符序列 | 可变字符序列 | 可变字符序列  |
| 是否线程安全 | 安全           | 安全         | 不安全        |



## 九 线程

### 线程五种状态

1.  新建
2.  就绪
3.  运行
4.  阻塞
5.  终止

### Thread.State类申明的六种线程状态

|        状态         |     名称      |
| :-----------------: | :-----------: |
|       1. 新建       |      new      |
|       2 运行        |   runnable    |
|       3 阻塞        |    blocked    |
| 4 等待 (时间不确定) |    waiting    |
| 5 等待（时间确定）  | timed_waiting |
|       6 终止        |  terminated   |

> 改变状态的方法
>
> -   start()启动
>
> -   sleep()睡眠
> -   interrupt()中断

### 两种线程对象实现方法

1.  继承Thread类
2.  实现runnable接口

>   线程对象由Thread类或其子类申明，执行run（）方法实现具体方法

### 优先级

1-10 越大越优，默认为5

>   main线程优先于其他线程执行。

### 定时器

Timer



### 线程间的竞争与互斥

#### 临界区调度原则

1.  无空等待
2.  有空让进
3.  择一而入
4.  算法可行

#### 资源竞争两大问题

1.  死锁
2.  饥饿

>    在多线程系统中，多个线程之间有**同步**和**互斥**两种关系。

#### 线程互斥实现:synchronized()

#### 线程同步

-   协作之间互相等待对方消息或信号的协作关系
-   PV操作：

1.  P:测试信号量状态
2.  V改变信号量状态

-   java线程通信方法：wait()、notify()等



------

### 多线程

#### 多线程解决的问题：

-   程序中需要执行耗时任务时。如数据库读写，io操作
-   程序中需要等待的任务。用户输入，文件读取。进行io操作时单线程程序的cpu是空闲的
-   目的：提高cpu利用率

### 进程与线程关系

进程包含线程
实现runnable接口优于继承thread接口，因为可以共享资源



### 线程池

### 解决的问题：

-   并发线程数量多，线程执行时间短，频繁创建和销毁线程消耗资源系统效率低下。

### 优势：

-   使线程得到复用



## 杂项

### java.util.Arrays学习记录

| 方法               | 用途             |
| ------------------ | ---------------- |
| binarySearch       | 二分查找         |
| copyOf/copyOfRange | 复制（深拷贝）   |
| equals             | 内容的比较       |
| fill               | 填充数组         |
| hashCode           | 基于内容的哈希值 |
| sort               | 升序排序         |
| toString           | 输出             |

> 常见哈希值算法:
>
> 1：Object类的hashCode.返回对象的内存地址经过处理后的结构，由于每个对象的内存地址都不一样，所以哈希码也不一样。
> 2：String类的hashCode.根据String类包含的字符串的内容，根据一种特殊算法返回哈希码，只要字符串内容相同，返回的哈希码也相同。
>
> 3：Integer类，返回的哈希码就是Integer对象里所包含的那个整数的数值，例如Integer i1=new Integer(100),i1.hashCode的值就是100 
>
> [参考资料](https://blog.csdn.net/diqye2011/article/details/7641406 )







### string写入txt文件

```java
File file = new File("e:\\temp.txt");
OutputStream out=null;
String outPutString="";

byte b[] = outPutString.getBytes();
try {
out.write(b);
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
```

> 注意换行是\r\n





### 同步交互：

- 指发送一个请求,需要等待返回,然后才能够发送下一个请求，有个等待过程；



### 异步交互：

- 指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。 区别：一个需要等待，一个不需要等待，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式。



调节Tomcat启动时间：

[如何调节tomcat启动时间](https://jingyan.baidu.com/article/e52e3615645fc940c60c51bf.html)