面试题看了很多，但是距离自己能表述给面试官听还是有很大差距。

这里做一些整理与复习。

## jre和jdk区别 

> 参考资料
>
> - [JDK and JRE File Structure](https://docs.oracle.com/javase/6/docs/technotes/tools/windows/jdkfiles.html)

- jre：java运行时环境，包含java虚拟机和java核心类库。

- jdk：java开发工具包，包含jre和一些java小工具。

![jdk](.\picture\面试题\jdk.PNG)

## java配置环境变量以及原因

> 参考资料
>
> - [JAVA为什么要配置环境变量，怎样配置](https://www.cnblogs.com/zhangpengshou/p/4232204.html)
> - [Java环境变量中classpath是必须配置吗](https://zhidao.baidu.com/question/1605930365893725827.html)

| 环境变量  | 内容            | 原因                   |
| --------- | --------------- | ---------------------- |
| JAVA_HOME | JDK的安装目录   | 便于其他环境变量的引用 |
| CLASSPATH | %JAVA_HOME%\lib | 指定标准类库路径       |
| path      | %JAVA_HOME%\bin | 指定可执行文件的路径   |



## 抽象类和接口区别 

> 参考资料
>
> - [Java抽象类与接口的区别](http://www.importnew.com/12399.html)

- 抽象类是对**类**的抽象，用来捕捉子类的通用特性；<br>接口是对**动作**的抽象，是抽象方法的集合。

| **参数**           | **抽象类**                                                   | **接口**                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 默认的方法实现     | 它可以有默认的方法实现                                       | 接口完全是抽象的。它根本不存在方法的实现                     |
| 实现               | 子类使用**extends**关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字**implements**来实现接口。它需要提供接口中所有声明的方法的实现 |
| 构造器             | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 与正常Java类的区别 | 除了你不能实例化抽象类之外，它和普通Java类没有任何区别       | 接口是完全不同的类型                                         |
| 访问修饰符         | 抽象方法可以有**public**、**protected**和**default**这些修饰符 | 接口方法默认修饰符是**public**。你不可以使用其它修饰符。     |
| main方法           | 抽象方法可以有main方法并且我们可以运行它                     | 接口没有main方法，因此我们不能运行它。                       |
| 多继承             | 抽象方法可以继承一个类和实现多个接口                         | 接口只可以继承一个或多个其它接口                             |
| 速度               | 它比接口速度要快                                             | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。   |
| 添加新方法         | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 | 如果你往接口中添加方法，那么你必须改变实现该接口的类。       |



## 数据库分页

1. mysql ： limit
2. oracle ： where中使用rownum
3. mysql ： top

### 数据库引擎

> 参考资料:
>
> - [Mysql常用的三种数据库引擎比较](https://blog.csdn.net/T146lLa128XX0x/article/details/78737290)

**InnoDB**：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 

**MyISAM**：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。

**MEMORY**：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。

注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。

### SQL中的join

| INNER JOIN | LEFT /RIGHT [OUTER] JOIN     | FULL [OUTER] JOIN | CROSS JOIN |
| ---------- | ---------------------------- | ----------------- | ---------- |
| 交集       | 左/右表完全集，右/左的关联集 | 并集              | 笛卡尔乘积 |

