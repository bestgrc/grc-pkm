# ACID

数据库事务必须同时满足ACID这4个特性：

|      | 原子性                                                       | 一致性                                                       | 隔离性                                                       | 持久性                                                       |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 英文 | Atomic[əˈtɒmɪk]                                              | Consistency                                                  | Isolation[ˌaɪsəˈleɪʃn]                                       | Durabiliy[ˌdjʊərəˈbɪlɪti]                                    |
| 描述 | **组成一个事务的多个数据库操作是一个不可分割的原子单元。**   | 事务操作成功后，数据库所处的状态和它的业务规则是一致的，**数据不会被破坏** | 在并发数据操作时，不同的事务拥有各自的数据控件，彼此互不干扰。 | 一旦事务提交成功后，事务中的所有数据操作都必须被持久化到数据库中。 |
| 备注 | 只有所有的操作执行成功，整个事务才提交。<br/>事务中的任何一个操作失败，已执行的任何操作必须撤销，然数据库返回到初始状态 | 一致性时最终目标，其他措施都是为了达到这个目标而采取的措施、要求或手段。 | （根据不通隔离级别，干扰程度不通）                           | 即使在提交成功后，数据库马上崩溃，在数据库重启时，也必须保证能通过某种机制恢复数据。 |

​	数据库如何保证ACID？

- 数据库一般使用**重执行日志**来保证**原子性、一致性和持久性**。
  - 重执行日志记录了数据库变化的每一个动作。
  - 数据库在一个事务执行一部分操作之后发生错误退出，数据库也可根据重执行日志来撤销已执行的操作。
  - 对于已提交的事务，即使数据库崩溃，在重启数据库时也能够根据日志对尚未持久化的数据进行相应的重执行操作。

- 数据库使用**锁机制**保证事务的**隔离性**。



# 5类数据并发的问题

## 3类数据读问题

|      | 脏读                     | 不可重复读                                                   | 幻读                                                         |
| ---- | ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 英文 | Dirty Read               | Unrepeatable Read                                            | Phantom[ˈfæntəm] Read                                        |
| 描述 | 读到其他事务未提交的数据 | 同一事务中的两个相同读操作间有其他事务更改了数据，导致这两次相同的读操作读到的数据不一致。 | 同一事务中的两个相同读操作间有其他事务更改了数据，导致这两次相同的读操作读到的数据不一致。（一般发生在计算统计数据的事务中） |
| 备注 |                          | 读已提交事务的更改数据（更新或删除）。                       | 读已提交事务的新增数据。                                     |

统计一般是不要求强一致性的，所以除非特殊业务要求，可以允许幻读，

关于为什么可以脏读：数据库读取可能会从**寄存器---一级缓存---二级缓存---内存---硬盘**五个地方读取，

参考[为什么一个事务能读取到其他事务修改后未提交的数据？](https://www.zhihu.com/question/60458495)

## 2类数据更新问题

|      | 第一类丢失更新                                               | 第二类丢失更新                                               |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 描述 | A事务在查询----更新----撤销的过程中，B事务在A事务“查询----更新“的过程中提交修改了要更新的数据。A事务撤销后导致B事务的丢失 | A事务在查询----更新----提交的过程中，B事务在A事务“查询----更新“的过程中提交修改了要更新的数据。A事务的提交导致B事务的丢失 |
| 备注 | 该记录已被B更新加锁，A的更新会超时失败。                     |                                                              |



# 事务隔离级别

解决以上并发问题，就需要使用到锁机制，而不通的锁机制又导致不通的隔离级别

|                | 读未提交        | 读已提交       | 可重复度          | 可串行化                                                   |
| -------------- | --------------- | -------------- | ----------------- | ---------------------------------------------------------- |
| 英文           | Read Uncommited | Read Committed | Repeatable Read   | Serializable                                               |
| 使用锁情况     | 读写均不使用锁  | 使用写锁       | 使用读锁和写锁    | 串行化调度                                                 |
| 脏读           | ✔               |                |                   |                                                            |
| 不可重复读     | ✔               | ✔              |                   |                                                            |
| 幻读           | ✔               | ✔              | ✔                 |                                                            |
| 第一类丢失更新 |                 |                |                   |                                                            |
| 第二类丢失更新 | ✔               | ✔              |                   |                                                            |
| 备注           |                 |                | mysql默认隔离级别 | 因为对于新增数据根本无法加锁，所以只能通过强制事务排序实现 |

# 数据库中的锁



mysql 系统设置 



关于事务的最小单位，

操作多条数据的一个sql是否是一个事务等还需明确。



**是否自动提交**

show global variables like 'autocommit';

show SESSION variables like 'autocommit';

**设置不自动提交**

set global autocommit=0;







事务的嵌套，有事务方法与未开启事务方法互相嵌套、代理的满足条件





有一篇比较详细的博文

[数据库事务与锁详解](https://blog.csdn.net/hemeinvyiqiluoben/article/details/80928070)