## 一、what is Redis

- Redis 是一个 key-value数据库
- Redis 提供五种数据类型：

| 类型       | 备注                                                         |
| ---------- | ------------------------------------------------------------ |
| string     |                                                              |
| hash       | key-value集合                                                |
| list       | 双向链表                                                     |
| set        |                                                              |
| sorted set | 每个元素都会关联一个double类型的权重参数。redis通过权重参数来为集合中的成员进行从小到大的排序。 |



## 二、why Redis —— Redis 的优势

- 性能极高
- 丰富的数据类型 
- 原子性 
- 丰富的特性 
  - Redis支持 publish/subscribe, 通知, key 过期等等特性。



## 三、when Redis

在项目中使用 Redis，主要考虑两个角度：**性能**和**并发**。

> 如果要求缓存与数据库必须一致，则不能使用redis

### 1. 性能

Redis能读的速度是110000次/s,写的速度是81000次/s

### 2. 并发

在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接访问数据库。

### 3. 使用场景

#### String

- 计数功能
  - Value 可以是 String 也可以是数字。

#### Hash

- 单点登录
  - 以 CookieId 作为 Key，设置缓存过期时间，能很好的模拟出类似 Session 的效果。

#### List

- 消息队列
- 基于 Redis 的分页
  - 利用 lrange 命令

#### Set

- 全局去重

#### Sorted Set

- 排行榜应用
  - 取 TOP N 操作。

- 延时任务。



## 五、Redis高性能的原因

- 纯内存操作

  - 所有数据存在内存中

- 采用了**非阻塞 I/O 多路复用**事件驱动机制

  - 单进程单线程处理客户端请求，避免了频繁的上下文切换

  - 通过记录跟踪每一个Sock(I/O流)的状态来同时管理多个I/O流

  > 封装了底层的 **select、epoll、avport 以及 kqueue**这些 I/O 多路复用函数



## 六、事务

- MULTI, EXEC, DISCARD 和WATCH命令是Redis事务操作的基础 。
- **不支持**回滚操作，事物队列中某个命令执行错误，整个事物也会继续执行下去。
  - 原因
    1. 只有当被调用的Redis命令有语法错误时，这条命令才会执行失败（在将这个命令放入事务队列期间，Redis能够发现此类问题），或者对某个键执行不符合其数据类型的操作：实际上，这就意味着只有程序错误才会导致Redis命令执行失败，这种错误很有可能在程序开发期间发现，一般很少在生产环境发现。 
    2. Redis已经在系统内部进行功能简化，这样可以确保更快的运行速度，因为Redis不需要事务回滚的能力。



####  redis 事务的 CAS 方案

> Optimistic locking using check-and-set(乐观锁)

WATCH 可以用来监听事务中的队列中的命令，在EXEC之前，一旦发现有一个命令被修改了的 , 那么整个事务就会终止， EXEC返回一个 Null ，提示用户事务失败了。



## 七、存储机制

### 1. AOF

​	记录每一次变更

### 2. RDB 

​	是将数据先存储在内存，然后当数据累计达到某些设定的伐值的时候，就会触发一次DUMP操作，将变化的数据一次性写入数据文件（RDB文件）。



## 八、内存机制

### Redis内存划分

#### 1、数据

- 在Redis内部，每种类型可能有2种或更多的内部编码实现；此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装

#### 2、进程本身运行需要的内存

- 主进程，如代码、常量池等

- 这部分很小，大约几兆

#### 3、缓冲内存

#### 4、内存碎片



### 内存回收策略

- 当内存使用情况达到maxmemory时触发内存回收策略
- 主要靠惰性删除，辅以定时删除

#### 2. 惰性删除

- 客户端访问时删除

#### 1. 定时删除

- Redis内部维护了一个定时任务，默认是每秒运行十次
- 随机检查是否过期，不是全覆盖
  - 所以一条数据到了时间不一定会被删除掉



## 使用 Redis 的常见问题

### 1. 缓存和数据库双写一致性问题

#### 问题描述

> 比较复杂，回头再更新

#### 解决方案

1. 先更新数据库，再更新缓存 (不推荐)
2. 先删缓存，再更新数据库
3. 先更新数据库，再删缓存

>  详情看参考资料
>
> - [Redis使用总结（二、缓存和数据库双写一致性问题）](<https://blog.csdn.net/hukaijun/article/details/81010475>)



### 2. 缓存雪崩问题

#### 问题描述

- 大量缓存在某一时刻集体过期，新收到的请求全部涌向数据库，压力过大，造成雪崩。

#### 解决方案

- 设置过期时间时，加上一个随机值



### 3. 缓存击穿问题

#### 问题描述

- 大量缓存在某一时刻集体过期，新收到的请求全部涌向数据库，压力过大，造成雪崩。

#### 解决方案

- 设置过期时间时，加上一个随机值



### 4. 缓存穿透问题

#### 问题描述

- 一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

#### 解决方案

- 设置为永不过期



### 5. 缓存的并发竞争问题

#### 问题描述

- 多客户端同时写一个 key，可能本来应该先到的数据后到了，导致数据版本错了。

- 多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。

#### 解决方案

1. 分布式锁+时间戳
2. 使用消息队列



## 附录：参考资料

[为什么我们做分布式使用 Redis ？](https://zhuanlan.zhihu.com/p/50392209)

[深入了解一下Redis的内存模型！](https://www.cnblogs.com/qwangxiao/p/8921171.html)

[推荐 redis的高级事务CAS(乐观锁)](https://blog.csdn.net/bigtree_3721/article/details/79633662)

[为什么Redis不支持回滚？](<https://blog.csdn.net/qq_41934990/article/details/81612095>)